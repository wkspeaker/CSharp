using System;
using System.Collections.Generic;
using System.Linq;

namespace LangrisserTools.TmpActivityCalculation.Services
{
 /// <summary>
 ///计算达到指定 A/B/C 奖励所需的最小行动次数（新规则，使用改进的贪心边际收益策略）
 /// </summary>
 public static class RoundsCalculator
 {
 public sealed class RoundsResult
 {
 public bool Possible { get; init; }
 public int TotalRounds { get; init; }
 public int TotalSaladUses { get; init; }
 public int TotalNormalUses { get; init; }
 // per-category counts in order A,B,C
 public int[] SaladUsesPerCategory { get; init; } = new int[3];
 public int[] NormalUsesPerCategory { get; init; } = new int[3];

 // produced amounts for verification
 public long[] ProducedBySaladPerCategory { get; init; } = new long[3];
 public long[] ProducedByNormalPerCategory { get; init; } = new long[3];
 public long[] TotalProducedPerCategory { get; init; } = new long[3];
 }

 /// <summary>
 ///计算最少行动次数
 /// </summary>
 public static RoundsResult CalculateMinimumRounds(
 int needA, int needB, int needC,
 int saladAmount, int normalAmount,
 int maxSaladUses =40)
 {
 if (needA <0 || needB <0 || needC <0)
 throw new ArgumentException("需要的奖励数量不得为负数。");
 if (maxSaladUses <0) throw new ArgumentException("maxSaladUses不能为负数。");
 if (saladAmount <0 || normalAmount <0) throw new ArgumentException("奖励数量不能为负数。");

 // Edge cases
 if (saladAmount ==0 && normalAmount ==0)
 {
 if (needA ==0 && needB ==0 && needC ==0)
 {
 return new RoundsResult { Possible = true, TotalRounds =0, TotalSaladUses =0, TotalNormalUses =0 };
 }
 return new RoundsResult { Possible = false, TotalRounds = -1 };
 }

 int[] needs = new int[] { needA, needB, needC };
 int[] sUses = new int[3];

 // If normalAmount ==0, we must cover that category entirely with salads
 int mandatorySalad =0;
 if (normalAmount ==0)
 {
 if (saladAmount ==0)
 {
 // handled above
 return new RoundsResult { Possible = false, TotalRounds = -1 };
 }

 for (int i =0; i <3; i++)
 {
 if (needs[i] >0)
 {
 int req = (int)CeilDiv(needs[i], saladAmount);
 sUses[i] = req;
 mandatorySalad += req;
 }
 }

 if (mandatorySalad > maxSaladUses)
 {
 return new RoundsResult { Possible = false, TotalRounds = -1 };
 }
 }

 int remainingSaladBudget = maxSaladUses - mandatorySalad;

 // compute initial required normals after mandatory salads
 long[] rem = new long[3];
 long[] reqNormal = new long[3];
 for (int i =0; i <3; i++)
 {
 rem[i] = Math.Max(0, (long)needs[i] - (long)sUses[i] * saladAmount);
 reqNormal[i] = (normalAmount >0) ? CeilDiv(rem[i], normalAmount) : (rem[i] ==0 ?0 : long.MaxValue);
 }

 // If already impossible
 if (reqNormal[0] == long.MaxValue || reqNormal[1] == long.MaxValue || reqNormal[2] == long.MaxValue)
 {
 return new RoundsResult { Possible = false, TotalRounds = -1 };
 }

 // Build list of marginal deltas for each possible extra salad use per category
 var deltas = new List<(int delta, int category)>();
 int maxExtraPerCategory = remainingSaladBudget; // safe upper bound per category
 for (int cat =0; cat <3; cat++)
 {
 // simulate adding extra salads one by one for this category
 int currentS = sUses[cat];
 for (int extra =1; extra <= maxExtraPerCategory; extra++)
 {
 int sBefore = currentS + extra -1;
 int d = ComputeDelta(needs[cat], saladAmount, normalAmount, sBefore);
 if (d <=0)
 {
 // further extras might still produce positive delta later, but since ComputeDelta is non-increasing with s? not strictly, we still continue
 // we still add the delta (could be zero), later we'll select top positive deltas only
 }
 deltas.Add((d, cat));
 }
 }

 // pick the top deltas up to remainingSaladBudget
 var selected = deltas.OrderByDescending(x => x.delta).Take(remainingSaladBudget).Where(x => x.delta >0).ToList();

 // apply selected salads
 foreach (var item in selected)
 {
 sUses[item.category]++;
 }

 // After applying selected salads, recompute final required normals
 for (int i =0; i <3; i++)
 {
 rem[i] = Math.Max(0, (long)needs[i] - (long)sUses[i] * saladAmount);
 reqNormal[i] = (normalAmount >0) ? CeilDiv(rem[i], normalAmount) : (rem[i] ==0 ?0 : long.MaxValue);
 }

 if (reqNormal[0] == long.MaxValue || reqNormal[1] == long.MaxValue || reqNormal[2] == long.MaxValue)
 {
 return new RoundsResult { Possible = false, TotalRounds = -1 };
 }

 long totalNormal = reqNormal[0] + reqNormal[1] + reqNormal[2];
 int totalSal = sUses[0] + sUses[1] + sUses[2];
 long totalActions = totalSal + totalNormal;

 // result
 var result = new RoundsResult
 {
 Possible = true,
 TotalRounds = (int)totalActions,
 TotalSaladUses = totalSal,
 TotalNormalUses = (int)totalNormal,
 SaladUsesPerCategory = new int[] { sUses[0], sUses[1], sUses[2] },
 NormalUsesPerCategory = new int[] { (int)reqNormal[0], (int)reqNormal[1], (int)reqNormal[2] }
 };

 // produced amounts
 for (int i =0; i <3; i++)
 {
 result.ProducedBySaladPerCategory[i] = (long)result.SaladUsesPerCategory[i] * saladAmount;
 result.ProducedByNormalPerCategory[i] = (long)result.NormalUsesPerCategory[i] * normalAmount;
 result.TotalProducedPerCategory[i] = result.ProducedBySaladPerCategory[i] + result.ProducedByNormalPerCategory[i];
 }

 return result;
 }

 // compute how many normal uses would be reduced by adding one more salad use at current s
 private static int ComputeDelta(int need, int saladAmount, int normalAmount, int currentS)
 {
 long remBefore = Math.Max(0, (long)need - (long)currentS * saladAmount);
 long reqBefore = (normalAmount >0) ? CeilDiv(remBefore, normalAmount) : (remBefore ==0 ?0 : long.MaxValue);

 long remAfter = Math.Max(0, (long)need - (long)(currentS +1) * saladAmount);
 long reqAfter = (normalAmount >0) ? CeilDiv(remAfter, normalAmount) : (remAfter ==0 ?0 : long.MaxValue);

 if (reqBefore == long.MaxValue || reqAfter == long.MaxValue) return0;
 return (int)(reqBefore - reqAfter);
 }

 private static long CeilDiv(long numerator, long denominator)
 {
 if (denominator <=0) throw new ArgumentException("分母必须为正数。", nameof(denominator));
 return (numerator + denominator -1) / denominator;
 }
 }
}
